(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{340:function(v,_,t){"use strict";t.r(_);var a=t(5),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"静态资源优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态资源优化"}},[v._v("#")]),v._v(" 静态资源优化")]),v._v(" "),_("p",[v._v("减少静态资源的加载时间，主要包括"),_("code",[v._v("html")]),v._v("、"),_("code",[v._v("css")]),v._v("、"),_("code",[v._v("js")]),v._v("和图片文件等。静态资源的加载时间是前端性能最大的瓶颈(特别是图片)，现如今优化的手段也很丰富，以下简要列举几种常用的方法:")]),v._v(" "),_("ul",[_("li",[v._v("合并 "),_("code",[v._v("css")]),v._v("、"),_("code",[v._v("js")]),v._v(" 文件，制作雪碧图: 减少 "),_("code",[v._v("http")]),v._v(" 的请求次数，节省网络请求时间")]),v._v(" "),_("li",[v._v("静态资源 cdn 分发: 客户端可以通过最佳的网络链路加载静态资源")]),v._v(" "),_("li",[_("code",[v._v("js")]),v._v("、"),_("code",[v._v("css")]),v._v(" 文件压缩，图片压缩，gzip 压缩: 减少请求返回的数据量")]),v._v(" "),_("li",[v._v("静态资源缓存机制")]),v._v(" "),_("li",[v._v("权衡 dns 的查找")])]),v._v(" "),_("h2",{attrs:{id:"接口访问优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口访问优化"}},[v._v("#")]),v._v(" 接口访问优化")]),v._v(" "),_("p",[v._v("静态资源优化做好了，可以保证静态资源以一个较快的速度加载出来，然而，此时情况并没有完美，依然存在两个明显的问题:")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("静态资源加载完了，页面依然在 loading 中，用户依然还在等待。现如今 web 应用已经走过完全由 php 和 jsp 等后端脚本语言渲染界面的时代，ajax 异步加载数据的方式已经成为主流，各种前端的 mvc 框架层出不穷，现加载静态资源，再执行 JS 中的 ajax 请求到后台请求数据，重新渲染界面已经是一种通行方案，这样便出现了静态资源加载完成，页面可见，然后用户还需要等待数据的进度条情况(特别是接口访问速度慢的时候)")])]),v._v(" "),_("li",[_("p",[v._v("用户点击任意一个按钮，进度条加载了半天，也没有响应。很多复杂的功能需要并行或者串行的请求很多接口才能完成，前端网络状况稍微差一点，给与用户的体验都极差")])])]),v._v(" "),_("p",[v._v("以上两个问题在网络情况优异，接口请求速度快的情况下都不是问题，然而终端如果是一个手机，常常连 wifi 都不能保证，3g/4g 的网络比较慢，所以优化的潜力是巨大的。")]),v._v(" "),_("h3",{attrs:{id:"首屏直出、同构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#首屏直出、同构"}},[v._v("#")]),v._v(" 首屏直出、同构")]),v._v(" "),_("p",[v._v("对于上述问题，如果页面的初始化数据，在后端完成渲染，其他的用户交互使用 ajax 的方式完成，也就是传统意义上的首屏直出，就可以得到很好的解决")]),v._v(" "),_("p",[v._v("这种介于完全后端渲染和完全 ajax 渲染的方式是一个不错的思路，但是在 node 出现之前，很多人宁愿容忍首屏加载的 loading 动画，也不愿意使用，为什么？因为前端和后端要维护两套模板，令人抓狂，node 出来之后，前后端都可以使用 js 语言，前后端同构(前端和后台公用模板代码)使得首屏直出重新拥有了生存的土壤，所以同构直出现。")]),v._v(" "),_("h3",{attrs:{id:"接口合并"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口合并"}},[v._v("#")]),v._v(" 接口合并")]),v._v(" "),_("p",[v._v("一个交互需要请求多个并行或串行接口实属正常，前端使用 3g/4g 等弱网络也着实是不可抗因素，所以最好的办法就是通过接口合并的方式来提高接口的访问速度")]),v._v(" "),_("p",[v._v("后台提供的接口既有粒度、强行合并不合时宜，提供一个新的合并的接口也缺乏机动性(前端发现一个新的合并需求，就要求后端提供一个接口，后端有开发量不说，还得没完没了的发版)")]),v._v(" "),_("p",[v._v("如果把接口合并的主动权交给前端，那情况将会好很多，前端是最接近战火的地方，最知道应该如何组合接口。")]),v._v(" "),_("h2",{attrs:{id:"页面渲染速度优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染速度优化"}},[v._v("#")]),v._v(" 页面渲染速度优化")]),v._v(" "),_("p",[v._v("在页面不复杂、dom 层次不深的情况下，完成前两步的优化，就已经足够了。然而在复杂的页面上，却还有很大的优化空间，页面渲染速度的优化很大的程度上，依托程序员的个人编程素质，下面简要列举几点:")]),v._v(" "),_("ul",[_("li",[v._v("css 放在顶部: 优先渲染")]),v._v(" "),_("li",[v._v("js 放在底部:避免阻塞")]),v._v(" "),_("li",[v._v("减少 DOM 元素数量: 这个最能体现优化水平")]),v._v(" "),_("li",[v._v("img 标签要设置宽高: 减少重绘重排")]),v._v(" "),_("li",[v._v("...")])]),v._v(" "),_("p",[v._v("另外，新晋前端框架"),_("code",[v._v("vue")]),v._v("、"),_("code",[v._v("react")]),v._v("，虚拟 DOM 的渲染方案，在内存中进行 DOM diff 比较，做到最小化的操作真实 DOM (操作真实的 DOM 常常会成为性能瓶颈)，能极大的提高渲染速度")]),v._v(" "),_("h2",{attrs:{id:"参考链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[v._v("#")]),v._v(" 参考链接")]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://juejin.im/post/592d0f4ca0bb9f00570f4408",target:"_blank",rel:"noopener noreferrer"}},[v._v("前端性能优化的三个维度"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=s.exports}}]);